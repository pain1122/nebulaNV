NebulaNV â€” Auth & gRPC Integration Update (4-08-2025)
ğŸ§© New & Updated Modules
Auth Service (HTTP & gRPC)

GrpcAuthService
apps/auth-service/src/auth/grpc/grpc-auth.service.ts
â€“ Centralizes all outgoing gRPC calls to UserService: createUser, findUserWithHash, updateProfile, getUser, findUser, setRefreshToken, getUserWithHash.
â€“ Now uses shared bearer(token) helper from @nebula/grpc-auth for metadata injection.
â€“ Public RPCs (createUser, findUserWithHash, setRefreshToken) are called without metadata.

AuthService
apps/auth-service/src/auth/auth.service.ts
â€“ Consolidates JWT logic (signing, expiration config, refresh rotation).
â€“ Implements register, validateUser, login, refreshTokens, updateProfile, and getProfile.
â€“ Fixed expiresIn bug by normalizing env config (15m, 7d).

AuthController
apps/auth-service/src/auth/auth.controller.ts
â€“ Provides REST endpoints:

POST /auth/register

POST /auth/login

POST /auth/refresh

GET /auth/me

PUT /auth/me

GET /auth/admin-only
â€“ Fixed missing grpcAuth injection and async in /auth/me.
â€“ Guarded routes with JwtAuthGuard + @Roles() as appropriate.

User Service (HTTP & gRPC)

GrpcJwtAuthGuard
apps/user-service/src/user/grpc/grpc-jwt-auth.guard.ts
â€“ Validates JWT from gRPC metadata.
â€“ Returns proper gRPC error codes: UNAUTHENTICATED or PERMISSION_DENIED.

UserGrpcController
apps/user-service/src/user/grpc/user-grpc.controller.ts
â€“ Implements proto-defined RPCs: FindUser, GetUser, UpdateProfile, etc.
â€“ Public RPCs (CreateUser, FindUserWithHash, SetRefreshToken) bypass guard via @Public().
â€“ Guarded RPCs require JWT and enforce roles.

UserController
apps/user-service/src/user/user.controller.ts
â€“ REST endpoints:

GET /users/me

PUT /users/me
â€“ Both secured with JwtAuthGuard + @Roles().

Shared Packages

@nebula/grpc-auth
packages/grpc-auth
â€“ Centralized helpers and decorators:

@Public()

@Roles() + ROLES_KEY

bearer(token) for gRPC metadata injection
â€“ Removed duplicate local decorators from services.
â€“ Fixed build artifacts (dist/ only, no .js/.d.ts polluting src).

Bootstrap & Config

Hybrid Bootstrapping
â€“ Each service now runs HTTP + gRPC in parallel via NestFactory.create(AppModule) + .connectMicroservice().
â€“ Port mapping:

Auth Service: HTTP :3001, gRPC :50052

User Service: HTTP :3100, gRPC :50051

Product Service: HTTP :3003, gRPC :50053

Prisma Standardization
â€“ Normalized package.json scripts across services:

prisma:generate

prisma:migrate

prisma:studio

postinstall â†’ runs prisma generate
â€“ Restored original .env files (kept under source control for local dev, Docker override later).
â€“ Fixed product-service DB connectivity (consistent with user-service).

âœ… What Was Done

Health checks â†’ All services expose /health (public, no JWT required). DB ping included for user- and product-service.

Shared decorators â†’ Unified @Public, @Roles, and bearer() in @nebula/grpc-auth.

Auth pipeline fixed:

Register â†’ creates user via gRPC.

Login â†’ password verified, tokens issued.

Refresh â†’ refresh token rotates correctly.

/auth/me â†’ profile retrieval via gRPC getUser.

Bug fixes:

Missing Bearer in health routes â†’ fixed with @Public().

expiresIn misconfig â†’ fixed with proper env format.

grpc interceptors undefined â†’ resolved by using svc proxy methods only.

/auth/me crash â†’ fixed by adding grpcAuth injection and making it async.

Cleaner code: removed duplicate public.decorator.ts and inline md(token) functions; all now use shared helpers.

ğŸ§ª Feature Verification

AuthService (HTTP)

POST /auth/register â†’ 201 + new user

POST /auth/login â†’ { access_token, refresh_token }

POST /auth/refresh â†’ rotated tokens returned

GET /auth/me â†’ returns profile {id,email,role} via gRPC

PUT /auth/me â†’ updates email/password

GET /auth/admin-only â†’ requires admin role

AuthService (gRPC)

CreateUser, FindUserWithHash, SetRefreshToken â†’ public, used by register/login flows

GetUser, FindUser, UpdateProfile, GetUserWithHash â†’ protected, require metadata

UserService (HTTP)

GET /users/me, PUT /users/me â†’ secured via JWT

UserService (gRPC)

Public RPCs work without token (registration, login flows).

Protected RPCs enforce JWT metadata and roles correctly.

ProductService

Compiles and runs; health check returns DB status.

Product RPCs/REST not fully exercised yet, but proto + controller are wired.

â­ï¸ Next Steps

Postman Test Plan
â€“ Validate end-to-end: register â†’ login â†’ me â†’ update â†’ refresh â†’ product CRUD.

Codegen Automation
â€“ Add root script pnpm proto:gen â†’ CI friendly.

Error Mapping
â€“ Improve RPC error translation (e.g., NotFoundException â†’ gRPC NOT_FOUND).

Consolidation
â€“ Decide on /auth/me vs /users/me duplication â†’ possibly unify into /profile.

Phase 3
â€“ Begin scaffolding media-service (file uploads, deduplication, watermarking).
â€“ Reuse gRPC guards and metadata helpers.