 NebulaNV â€” Auth Module Progress Report (17-07-2025)
ğŸ§© Module
apps/user-service/src/auth

âœ… What Was Done
Role-Based Access Control (RBAC) System Introduced

Implemented a custom @Roles(...roles: string[]) decorator.

Created a RolesGuard to enforce required roles at route level.

Registered both JwtAuthGuard and RolesGuard as global guards via APP_GUARD.

Express Request Typings Extended

Augmented express.Request and express.User interfaces to support type-safe req.user access across controllers.

Controller Role Enforcement

Updated AuthController to include:

@Roles('admin') on a sample /auth/admin-only route.

@UseGuards(JwtAuthGuard) on all protected routes.

ğŸ—‚ï¸ Files & Directories Affected
yaml
Copy
Edit
apps/user-service/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ auth.controller.ts               â¬…ï¸ Updated: added role-protected route
â”‚   â”‚   â””â”€â”€ jwt/jwt-auth.guard.ts            âœ… Already in use
â”‚   â”œâ”€â”€ common/
â”‚   â”‚   â”œâ”€â”€ decorators/
â”‚   â”‚   â”‚   â””â”€â”€ roles.decorator.ts           ğŸ†• Added: @Roles decorator
â”‚   â”‚   â””â”€â”€ guards/
â”‚   â”‚       â””â”€â”€ roles.guard.ts               ğŸ†• Added: RolesGuard
â”‚   â””â”€â”€ app.module.ts                        â¬…ï¸ Updated: registered global guards
ğŸ§ª Feature Verification
âœ… POST /auth/register â€” Public route

âœ… POST /auth/login â€” Public route

âœ… GET /auth/me â€” JWT-protected route

âœ… GET /auth/admin-only â€” JWT + Role protected (admin only)

â­ï¸ Next Steps (Future Phases)
Add support for supervisor, moderator, and other roles.

Integrate role checking into gRPC metadata for inter-service access control.

Implement permission-based RBAC (if needed) with scoped policies.



NebulaNV â€” Profile Update & RBAC Refinement (20-07-2025)
Today, we completed the full userâ€profile update flow in the userâ€service, including secure password verification and roleâ€based guards tuned per endpoint. We ironed out guard order issues, DTO validation rules, and manual database fixes, arriving at a stable, production-ready update profile feature.

ğŸ“ What We Built
PUT /users/me â€” Update Profile Endpoint

Controller: Added @Roles('user') to require an authenticated â€œuserâ€ role.

DTO: UpdateProfileDto uses @ValidateIf to require currentPassword only when changing password.

Service: updateProfile() now:

Fetches the user by ID.

Verifies currentPassword via bcrypt.

Updates email and/or hashes and updates newPassword.

Guard Improvements

Composite Guard (JwtAndRolesGuard) respects @Public(), runs JwtAuthGuard first, then RolesGuard.

RolesGuard now throws clear errors when:

No @Roles() metadata is present.

Userâ€™s role doesnâ€™t match the required roles.

Environment & DB Fixes

Fixed local PostgreSQL connection (moved off Docker) and updated DATABASE_URL to point at native Postgres on port 5432.

Manually verified and corrected user roles in the nebula database with psql.

ğŸ Key Challenges & Solutions
Challenge	Solution
Guard blocking public and user-only routes	Introduced JwtAndRolesGuard with a @Public() bypass and re-scoped @Roles() per route instead of applying RolesGuard globally.
DTO always requiring currentPassword even for email-only updates	Switched to @ValidateIf(dto => dto.newPassword !== undefined) so currentPassword is only validated when changing passwords.
Profile update failing due to stale placeholder password in tests	Added debug logging in updateProfile(), discovered placeholder "oldPassword123" was never changed, then corrected test payload.

ğŸ“ Directory Summary
pgsql
Copy
Edit
apps/user-service/src/
â”œâ”€â”€ auth/
â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â””â”€â”€ update-profile.dto.ts   (âœ“ Conditional password validation)
â”‚   â”œâ”€â”€ jwt/
â”‚   â”‚   â””â”€â”€ jwt-and-roles.ts        (âœ“ Composite guard: Public â†’ JWT â†’ Roles)
â”‚   â”œâ”€â”€ auth.controller.ts          (âœ“ @Public + protected admin route)
â”‚   â””â”€â”€ auth.module.ts              (âœ“ JWT setup)
â”œâ”€â”€ common/
â”‚   â””â”€â”€ guards/
â”‚       â””â”€â”€ roles.guard.ts          (âœ“ Throws on missing metadata or mismatched role)
â”œâ”€â”€ user/
â”‚   â”œâ”€â”€ user.controller.ts          (âœ“ GET /users, PUT /users/me, GET /users/:id)
â”‚   â””â”€â”€ user.service.ts             (âœ“ createUser, validateUser, updateProfile)
â”œâ”€â”€ prisma.service.ts               (âœ“ Prisma client init)
â””â”€â”€ app.module.ts                   (âœ“ Composite global guard registration)
ğŸ§ª Manual Testing
Registration & Login: âœ”ï¸ New â€œuserâ€ accounts created and authenticated.

GET /users/me: âœ”ï¸ Returns correct userId, email, role.

PUT /users/me:

Emailâ€only update âœ”ï¸

Password change with correct currentPassword âœ”ï¸

Error on incorrect currentPassword âœ”ï¸

GET /users (admin only) âœ”ï¸ Returns list; 403 for non-admin.

GET /users/:id âœ”ï¸ Admin or self only; 403 otherwise.

ğŸ—‚ Cleanup & Configuration
Env: DATABASE_URL set to postgres://postgres:postgres@localhost:5432/nebula.

Logging: Temporary debug logs in updateProfile() removed.

ğŸš€ Current Status
UserService: Fully supports profile updates with robust validation and RBAC.

AuthService: Stable JWT issuance and /auth/me.

Guards: Composite guard in place, correctly honoring @Public() and @Roles().

â­ Next Steps
Write Unit & e2e Tests for UserController.updateProfile, covering email-only and password flows.

Implement Refresh Tokens in AuthService (Phase 2 requirement).

Begin gRPC Integration for Auth â†’ UserService calls.

Scaffold Product-Service MVP, following the same pattern: DTOs, guards, PRISMA schemas, controllers, and tests.